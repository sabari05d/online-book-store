-- Create profiles table
create table public.profiles (
  id uuid references auth.users not null primary key,
  is_admin boolean default false,
  full_name text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create genres table
create table public.genres (
  id bigint generated by default as identity primary key,
  name text not null,
  slug text not null unique,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create books table
create table public.books (
  id bigint generated by default as identity primary key,
  title text not null,
  description text,
  price numeric not null,
  stock integer default 0,
  cover_url text,
  genre_id bigint references public.genres(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create carts table
create table public.carts (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users, -- Nullable for guest carts if we support them, or just session based
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create cart_items table
create table public.cart_items (
  id bigint generated by default as identity primary key,
  cart_id bigint references public.carts(id) on delete cascade,
  book_id bigint references public.books(id),
  quantity integer default 1,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create orders table
create table public.orders (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  total_amount numeric not null,
  status text default 'pending', -- pending, paid, shipped, cancelled
  shipping_address jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create order_items table
create table public.order_items (
  id bigint generated by default as identity primary key,
  order_id bigint references public.orders(id) on delete cascade,
  book_id bigint references public.books(id),
  quantity integer not null,
  price_at_purchase numeric not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table public.profiles enable row level security;
alter table public.genres enable row level security;
alter table public.books enable row level security;
alter table public.carts enable row level security;
alter table public.cart_items enable row level security;
alter table public.orders enable row level security;
alter table public.order_items enable row level security;

-- RLS Policies (Permissive for Dev/Demo)

-- Profiles: Public read, Self update
create policy "Public profiles are viewable by everyone." on public.profiles for select using (true);
create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
create policy "Users can update own profile." on public.profiles for update using (auth.uid() = id);

-- Genres: Public read, Admin write
create policy "Genres are viewable by everyone." on public.genres for select using (true);
create policy "Admins can insert genres." on public.genres for insert with check (exists (select 1 from public.profiles where id = auth.uid() and is_admin = true));
create policy "Admins can update genres." on public.genres for update using (exists (select 1 from public.profiles where id = auth.uid() and is_admin = true));
create policy "Admins can delete genres." on public.genres for delete using (exists (select 1 from public.profiles where id = auth.uid() and is_admin = true));

-- Books: Public read, Admin write
create policy "Books are viewable by everyone." on public.books for select using (true);
create policy "Admins can insert books." on public.books for insert with check (exists (select 1 from public.profiles where id = auth.uid() and is_admin = true));
create policy "Admins can update books." on public.books for update using (exists (select 1 from public.profiles where id = auth.uid() and is_admin = true));
create policy "Admins can delete books." on public.books for delete using (exists (select 1 from public.profiles where id = auth.uid() and is_admin = true));

-- Carts: Users can see their own carts (or public for demo simplicity if needed, but let's restrict)
-- For simplicity in this demo, we might allow public insert if we handle guest carts, but let's stick to auth users for now or permissive.
create policy "Carts are viewable by owner." on public.carts for select using (auth.uid() = user_id);
create policy "Users can create carts." on public.carts for insert with check (auth.uid() = user_id);
create policy "Users can update own carts." on public.carts for update using (auth.uid() = user_id);

-- Cart Items: Linked to cart
create policy "Cart items viewable by cart owner." on public.cart_items for select using (exists (select 1 from public.carts where id = cart_items.cart_id and user_id = auth.uid()));
create policy "Cart items insertable by cart owner." on public.cart_items for insert with check (exists (select 1 from public.carts where id = cart_items.cart_id and user_id = auth.uid()));
create policy "Cart items updatable by cart owner." on public.cart_items for update using (exists (select 1 from public.carts where id = cart_items.cart_id and user_id = auth.uid()));
create policy "Cart items deletable by cart owner." on public.cart_items for delete using (exists (select 1 from public.carts where id = cart_items.cart_id and user_id = auth.uid()));

-- Orders: Users see own, Admins see all
create policy "Users see own orders." on public.orders for select using (auth.uid() = user_id or exists (select 1 from public.profiles where id = auth.uid() and is_admin = true));
create policy "Users can create orders." on public.orders for insert with check (auth.uid() = user_id);
create policy "Admins can update orders." on public.orders for update using (exists (select 1 from public.profiles where id = auth.uid() and is_admin = true));

-- Order Items: Same as orders
create policy "Users see own order items." on public.order_items for select using (exists (select 1 from public.orders where id = order_items.order_id and (user_id = auth.uid() or exists (select 1 from public.profiles where id = auth.uid() and is_admin = true))));

-- Storage Bucket for Book Covers
insert into storage.buckets (id, name, public) values ('book-covers', 'book-covers', true) on conflict do nothing;

-- Storage Policies
create policy "Cover images are publicly accessible." on storage.objects for select using (bucket_id = 'book-covers');
create policy "Admins can upload cover images." on storage.objects for insert with check (bucket_id = 'book-covers' and exists (select 1 from public.profiles where id = auth.uid() and is_admin = true));
